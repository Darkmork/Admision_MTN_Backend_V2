name: Deploy with Canary Analysis
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - dev
        - staging
        - prod
      image_tag:
        description: 'Container image tag'
        required: true
        type: string
      force_promotion:
        description: 'Force promote without analysis'
        required: false
        default: false
        type: boolean
      rollback_version:
        description: 'Version to rollback (leave empty for deploy)'
        required: false
        type: string

env:
  TZ: America/Santiago
  HELM_CHART_PATH: ./helm/<service>
  SERVICE_NAME: <service>  # Se reemplaza por el nombre real del servicio
  NAMESPACE: mtn-<env>     # Se reemplaza por el namespace específico

jobs:
  validate-deployment:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.validate.outputs.environment }}
      image_tag: ${{ steps.validate.outputs.image_tag }}
      namespace: ${{ steps.validate.outputs.namespace }}
      is_rollback: ${{ steps.validate.outputs.is_rollback }}
      
    steps:
      - name: Validate Inputs
        id: validate
        run: |
          ENV="${{ github.event.inputs.environment }}"
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          ROLLBACK_VERSION="${{ github.event.inputs.rollback_version }}"
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "namespace=mtn-${ENV}" >> $GITHUB_OUTPUT
          
          if [ -n "${ROLLBACK_VERSION}" ]; then
            echo "image_tag=${ROLLBACK_VERSION}" >> $GITHUB_OUTPUT
            echo "is_rollback=true" >> $GITHUB_OUTPUT
            echo "🔄 Rollback mode: ${ROLLBACK_VERSION}"
          else
            echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
            echo "is_rollback=false" >> $GITHUB_OUTPUT
            echo "🚀 Deploy mode: ${IMAGE_TAG}"
          fi
          
          # Validar formato de tag
          if [[ ! "${IMAGE_TAG}" =~ ^[a-zA-Z0-9._-]+$ ]]; then
            echo "❌ Invalid image tag format: ${IMAGE_TAG}"
            exit 1
          fi
          
          echo "✅ Deployment validation passed"

  pre-deployment-checks:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    needs: validate-deployment
    environment: ${{ needs.validate-deployment.outputs.environment }}
    permissions:
      contents: read
      packages: read
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.13.0'

      # Configuración específica por proveedor cloud
      - name: Configure AWS Credentials
        if: vars.CLOUD_PROVIDER == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-session-name: GitHubActions-Deploy-${{ github.run_id }}

      - name: Setup EKS kubeconfig
        if: vars.CLOUD_PROVIDER == 'aws'
        run: |
          aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} --name ${{ vars.EKS_CLUSTER_NAME }}

      - name: Azure Login
        if: vars.CLOUD_PROVIDER == 'azure'
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup AKS kubeconfig
        if: vars.CLOUD_PROVIDER == 'azure'
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ vars.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME }}

      - name: Google Cloud Auth
        if: vars.CLOUD_PROVIDER == 'gcp'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Setup GKE kubeconfig
        if: vars.CLOUD_PROVIDER == 'gcp'
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ vars.GKE_CLUSTER_NAME }}
          location: ${{ vars.GCP_ZONE }}

      - name: Verify Cluster Access
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl get namespace ${{ needs.validate-deployment.outputs.namespace }} || \
            kubectl create namespace ${{ needs.validate-deployment.outputs.namespace }}

      - name: Verify Container Image
        run: |
          IMAGE="ghcr.io/${{ github.repository }}:${{ needs.validate-deployment.outputs.image_tag }}"
          
          # Verificar que la imagen existe
          docker pull ${IMAGE} || {
            echo "❌ Image not found: ${IMAGE}"
            exit 1
          }
          
          # Verificar firma de la imagen (si está disponible)
          cosign verify --certificate-identity-regexp ".*" --certificate-oidc-issuer-regexp ".*" ${IMAGE} || \
            echo "⚠️  Image signature verification failed - proceeding anyway"
          
          echo "✅ Image verification passed: ${IMAGE}"

      - name: Validate Helm Chart
        run: |
          helm dependency update ${{ env.HELM_CHART_PATH }}
          helm lint ${{ env.HELM_CHART_PATH }}
          helm template ${{ env.SERVICE_NAME }} ${{ env.HELM_CHART_PATH }} \
            --values ${{ env.HELM_CHART_PATH }}/values-${{ needs.validate-deployment.outputs.environment }}.yaml \
            --set image.tag=${{ needs.validate-deployment.outputs.image_tag }} \
            --dry-run --debug

      - name: Check Current Deployment Status
        run: |
          kubectl get rollout ${{ env.SERVICE_NAME }} -n ${{ needs.validate-deployment.outputs.namespace }} || \
            echo "No existing rollout found"
          
          kubectl get pods -l app=${{ env.SERVICE_NAME }} -n ${{ needs.validate-deployment.outputs.namespace }} || \
            echo "No existing pods found"

  deploy:
    name: Deploy Canary
    runs-on: ubuntu-latest
    needs: [validate-deployment, pre-deployment-checks]
    environment: ${{ needs.validate-deployment.outputs.environment }}
    permissions:
      contents: read
      packages: read
      
    outputs:
      deployment_id: ${{ steps.deploy.outputs.deployment_id }}
      rollout_name: ${{ steps.deploy.outputs.rollout_name }}
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Tools
        uses: azure/setup-helm@v4
        with:
          version: '3.13.0'

      - name: Install Argo Rollouts Plugin
        run: |
          curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

      - name: Deploy with Helm
        id: deploy
        run: |
          DEPLOYMENT_ID="deploy-$(date +%s)-${{ github.run_number }}"
          echo "deployment_id=${DEPLOYMENT_ID}" >> $GITHUB_OUTPUT
          echo "rollout_name=${{ env.SERVICE_NAME }}" >> $GITHUB_OUTPUT
          
          echo "🚀 Starting deployment: ${DEPLOYMENT_ID}"
          echo "📦 Image: ghcr.io/${{ github.repository }}:${{ needs.validate-deployment.outputs.image_tag }}"
          echo "🎯 Environment: ${{ needs.validate-deployment.outputs.environment }}"
          
          # Preparar values con metadatos de deployment
          cat > deployment-values.yaml << EOF
          image:
            tag: "${{ needs.validate-deployment.outputs.image_tag }}"
          
          build:
            sha: "${{ github.sha }}"
            url: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            deploymentId: "${DEPLOYMENT_ID}"
            timestamp: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            triggeredBy: "${{ github.actor }}"
          
          deployment:
            environment: "${{ needs.validate-deployment.outputs.environment }}"
            isRollback: ${{ needs.validate-deployment.outputs.is_rollback }}
          EOF
          
          # Ejecutar deployment
          helm upgrade --install ${{ env.SERVICE_NAME }} ${{ env.HELM_CHART_PATH }} \
            --namespace ${{ needs.validate-deployment.outputs.namespace }} \
            --values ${{ env.HELM_CHART_PATH }}/values-${{ needs.validate-deployment.outputs.environment }}.yaml \
            --values deployment-values.yaml \
            --timeout 10m \
            --wait \
            --atomic

      - name: Wait for Rollout Start
        run: |
          echo "⏳ Waiting for rollout to start..."
          kubectl-argo-rollouts get rollout ${{ env.SERVICE_NAME }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            --watch --timeout 300s

  canary-analysis:
    name: Canary Analysis
    runs-on: ubuntu-latest
    needs: [validate-deployment, deploy]
    if: github.event.inputs.force_promotion != 'true' && needs.validate-deployment.outputs.is_rollback == 'false'
    environment: ${{ needs.validate-deployment.outputs.environment }}
    timeout-minutes: 30
    
    steps:
      - name: Monitor Canary Deployment
        run: |
          echo "📊 Starting canary analysis..."
          echo "🔍 Monitoring rollout: ${{ needs.deploy.outputs.rollout_name }}"
          
          # Monitorear el progreso del canary
          kubectl-argo-rollouts get rollout ${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            --watch --timeout 1800s  # 30 minutos máximo
          
          # Verificar estado final
          ROLLOUT_STATUS=$(kubectl-argo-rollouts get rollout ${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} -o jsonpath='{.status.phase}')
          
          echo "Final rollout status: ${ROLLOUT_STATUS}"
          
          if [ "${ROLLOUT_STATUS}" = "Healthy" ]; then
            echo "✅ Canary analysis completed successfully"
          elif [ "${ROLLOUT_STATUS}" = "Paused" ]; then
            echo "⏸️  Canary deployment paused - manual intervention required"
            exit 2  # Exit code 2 para diferenciarlo de fallos
          else
            echo "❌ Canary analysis failed: ${ROLLOUT_STATUS}"
            exit 1
          fi

      - name: Collect Canary Metrics
        if: always()
        run: |
          echo "📈 Collecting deployment metrics..."
          
          # Métricas de pods
          kubectl get pods -l app=${{ env.SERVICE_NAME }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            -o wide > canary-pods.txt
          
          # Estado del rollout
          kubectl-argo-rollouts get rollout ${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            -o yaml > rollout-status.yaml
          
          # Eventos relacionados
          kubectl get events --field-selector involvedObject.name=${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            --sort-by='.lastTimestamp' > deployment-events.txt

      - name: Upload Canary Metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: canary-metrics-${{ needs.validate-deployment.outputs.environment }}-${{ github.run_number }}
          path: |
            canary-pods.txt
            rollout-status.yaml
            deployment-events.txt

  promote-or-rollback:
    name: Promote or Rollback
    runs-on: ubuntu-latest
    needs: [validate-deployment, deploy, canary-analysis]
    if: always() && needs.deploy.result == 'success'
    environment: 
      name: ${{ needs.validate-deployment.outputs.environment }}-promotion
      url: ${{ steps.promotion.outputs.service_url }}
    
    steps:
      - name: Determine Action
        id: action
        run: |
          FORCE_PROMOTION="${{ github.event.inputs.force_promotion }}"
          CANARY_RESULT="${{ needs.canary-analysis.result }}"
          IS_ROLLBACK="${{ needs.validate-deployment.outputs.is_rollback }}"
          ENVIRONMENT="${{ needs.validate-deployment.outputs.environment }}"
          
          if [ "${IS_ROLLBACK}" = "true" ]; then
            echo "action=promote" >> $GITHUB_OUTPUT
            echo "reason=rollback" >> $GITHUB_OUTPUT
            echo "🔄 Rollback deployment - auto-promoting"
          elif [ "${FORCE_PROMOTION}" = "true" ]; then
            echo "action=promote" >> $GITHUB_OUTPUT
            echo "reason=forced" >> $GITHUB_OUTPUT
            echo "⚡ Force promotion requested"
          elif [ "${CANARY_RESULT}" = "success" ]; then
            echo "action=promote" >> $GITHUB_OUTPUT
            echo "reason=analysis_passed" >> $GITHUB_OUTPUT
            echo "✅ Canary analysis passed - promoting"
          elif [ "${CANARY_RESULT}" = "failure" ]; then
            echo "action=rollback" >> $GITHUB_OUTPUT
            echo "reason=analysis_failed" >> $GITHUB_OUTPUT
            echo "❌ Canary analysis failed - rolling back"
          elif [ "${ENVIRONMENT}" = "prod" ]; then
            echo "action=manual_approval" >> $GITHUB_OUTPUT
            echo "reason=production_gate" >> $GITHUB_OUTPUT
            echo "🛡️  Production deployment - manual approval required"
          else
            echo "action=promote" >> $GITHUB_OUTPUT
            echo "reason=default" >> $GITHUB_OUTPUT
            echo "➡️  Default action - promoting"
          fi

      - name: Manual Approval Gate
        if: steps.action.outputs.action == 'manual_approval'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ vars.PROD_APPROVERS }}
          minimum-approvals: 2
          issue-title: "🚀 Production Deployment Approval Required"
          issue-body: |
            ## Production Deployment Approval
            
            **Service:** ${{ env.SERVICE_NAME }}
            **Environment:** ${{ needs.validate-deployment.outputs.environment }}
            **Image:** ghcr.io/${{ github.repository }}:${{ needs.validate-deployment.outputs.image_tag }}
            **Deployment ID:** ${{ needs.deploy.outputs.deployment_id }}
            
            ### Canary Results
            Analysis completed with status: **${{ needs.canary-analysis.result }}**
            
            ### Pre-deployment Checklist
            - [ ] Security scans passed
            - [ ] Integration tests successful
            - [ ] Monitoring alerts configured
            - [ ] Rollback plan confirmed
            
            **Approve this deployment to promote to 100% traffic.**

      - name: Execute Promotion
        id: promotion
        if: steps.action.outputs.action == 'promote' || (steps.action.outputs.action == 'manual_approval' && success())
        run: |
          echo "🎯 Promoting rollout to 100%"
          
          kubectl-argo-rollouts promote ${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            --full
          
          # Esperar que la promoción complete
          kubectl-argo-rollouts get rollout ${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            --watch --timeout 600s
          
          # Obtener URL del servicio
          SERVICE_URL=$(kubectl get service ${{ env.SERVICE_NAME }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "cluster-internal")
          
          echo "service_url=https://${SERVICE_URL}" >> $GITHUB_OUTPUT
          echo "✅ Promotion completed successfully"

      - name: Execute Rollback
        if: steps.action.outputs.action == 'rollback'
        run: |
          echo "🔄 Rolling back deployment"
          
          kubectl-argo-rollouts abort ${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }}
          
          kubectl-argo-rollouts undo ${{ needs.deploy.outputs.rollout_name }} \
            -n ${{ needs.validate-deployment.outputs.namespace }}
          
          echo "✅ Rollback completed"

  post-deployment:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: [validate-deployment, deploy, promote-or-rollback]
    if: success()
    environment: ${{ needs.validate-deployment.outputs.environment }}
    
    steps:
      - name: Health Check
        run: |
          echo "🏥 Running post-deployment health checks"
          
          # Verificar que todos los pods están ready
          kubectl wait --for=condition=ready pod \
            -l app=${{ env.SERVICE_NAME }} \
            -n ${{ needs.validate-deployment.outputs.namespace }} \
            --timeout=300s
          
          # Verificar endpoint de health
          HEALTH_URL="http://${{ env.SERVICE_NAME }}.${{ needs.validate-deployment.outputs.namespace }}.svc.cluster.local:8080/actuator/health"
          
          kubectl run health-check-${{ github.run_number }} \
            --image=curlimages/curl:latest \
            --rm -i --restart=Never \
            --namespace=${{ needs.validate-deployment.outputs.namespace }} \
            -- curl -f "${HEALTH_URL}" || {
            echo "❌ Health check failed"
            exit 1
          }
          
          echo "✅ Health check passed"

      - name: Smoke Tests
        run: |
          echo "💨 Running smoke tests"
          
          # Test básico de conectividad
          kubectl run smoke-test-${{ github.run_number }} \
            --image=curlimages/curl:latest \
            --rm -i --restart=Never \
            --namespace=${{ needs.validate-deployment.outputs.namespace }} \
            -- curl -s -o /dev/null -w "%{http_code}" \
            "http://${{ env.SERVICE_NAME }}.${{ needs.validate-deployment.outputs.namespace }}.svc.cluster.local:8080/actuator/info" | grep -q "200"
          
          echo "✅ Smoke tests passed"

      - name: Update Deployment Status
        run: |
          echo "📊 Recording deployment completion"
          
          cat > deployment-summary.json << EOF
          {
            "deploymentId": "${{ needs.deploy.outputs.deployment_id }}",
            "service": "${{ env.SERVICE_NAME }}",
            "environment": "${{ needs.validate-deployment.outputs.environment }}",
            "imageTag": "${{ needs.validate-deployment.outputs.image_tag }}",
            "status": "completed",
            "promotionReason": "${{ needs.promote-or-rollback.outputs.reason }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "triggeredBy": "${{ github.actor }}",
            "workflowUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
          
          # Aquí se podría enviar a un sistema de tracking de deployments
          echo "📋 Deployment summary:"
          cat deployment-summary.json

  notify:
    name: Notify Deployment Result
    runs-on: ubuntu-latest
    needs: [validate-deployment, deploy, canary-analysis, promote-or-rollback, post-deployment]
    if: always()
    
    steps:
      - name: Determine Notification Status
        id: status
        run: |
          DEPLOY_STATUS="${{ needs.deploy.result }}"
          CANARY_STATUS="${{ needs.canary-analysis.result }}"
          PROMOTION_STATUS="${{ needs.promote-or-rollback.result }}"
          POST_STATUS="${{ needs.post-deployment.result }}"
          
          if [ "${POST_STATUS}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Deployment completed successfully" >> $GITHUB_OUTPUT
          elif [ "${PROMOTION_STATUS}" = "success" ]; then
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "message=Promoted but post-deployment checks failed" >> $GITHUB_OUTPUT
          elif [ "${CANARY_STATUS}" = "failure" ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "message=Canary analysis failed" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "message=Deployment failed" >> $GITHUB_OUTPUT
          fi

      - name: Slack Notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.status.outputs.status == 'success' && 'success' || 'failure' }}
          channel: '#deployments'
          username: 'Deployment Bot'
          icon_emoji: ${{ steps.status.outputs.status == 'success' && ':rocket:' || ':warning:' }}
          text: |
            ${{ steps.status.outputs.status == 'success' && '✅' || '❌' }} *Deployment ${{ steps.status.outputs.message }}*
            
            *Service:* ${{ env.SERVICE_NAME }}
            *Environment:* ${{ needs.validate-deployment.outputs.environment }}
            *Image:* `ghcr.io/${{ github.repository }}:${{ needs.validate-deployment.outputs.image_tag }}`
            *Deployment ID:* `${{ needs.deploy.outputs.deployment_id }}`
            *Triggered by:* ${{ github.actor }}
            
            ${{ steps.status.outputs.status == 'success' && '🎉 Service is live and healthy!' || '🚨 Please investigate the failure!' }}
            
            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Deployment>
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}