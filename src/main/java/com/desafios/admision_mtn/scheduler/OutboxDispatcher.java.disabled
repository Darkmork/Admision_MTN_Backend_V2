// src/main/java/com/desafios/admision_mtn/scheduler/OutboxDispatcher.java

package com.desafios.admision_mtn.scheduler;

import com.desafios.admision_mtn.outbox.OutboxEntity;
import com.desafios.admision_mtn.outbox.OutboxService;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageBuilder;
import org.springframework.amqp.core.MessageProperties;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Dispatcher que procesa eventos del Outbox y los publica a RabbitMQ
 */
@Slf4j
@Component
@ConditionalOnProperty(name = "notifications.outbox.enabled", havingValue = "true", matchIfMissing = true)
public class OutboxDispatcher {

    private final OutboxService outboxService;
    private final RabbitTemplate rabbitTemplate;
    private final ObjectMapper objectMapper;
    
    // Métricas
    private final Counter publishedEventsCounter;
    private final Counter failedEventsCounter;
    private final Timer publishingTimer;
    
    private static final String NOTIFICATIONS_EXCHANGE = "notifications.x";
    private static final int BATCH_SIZE = 50;
    private static final int MAX_RETRY_ATTEMPTS = 3;

    public OutboxDispatcher(OutboxService outboxService,
                           RabbitTemplate rabbitTemplate,
                           ObjectMapper objectMapper,
                           MeterRegistry meterRegistry) {
        this.outboxService = outboxService;
        this.rabbitTemplate = rabbitTemplate;
        this.objectMapper = objectMapper;
        
        // Inicializar métricas
        this.publishedEventsCounter = Counter.builder("outbox_events_published_total")
                .description("Total de eventos publicados desde el outbox")
                .tag("service", "monolith")
                .register(meterRegistry);
        
        this.failedEventsCounter = Counter.builder("outbox_events_failed_total")
                .description("Total de eventos fallidos al publicar desde el outbox")
                .tag("service", "monolith")
                .register(meterRegistry);
        
        this.publishingTimer = Timer.builder("outbox_publishing_duration_seconds")
                .description("Tiempo de procesamiento de eventos del outbox")
                .tag("service", "monolith")
                .register(meterRegistry);
    }

    /**
     * Procesa eventos del outbox cada 5 segundos
     */
    @Scheduled(fixedDelayString = "${notifications.outbox.processing-interval:5000}")
    @Transactional
    public void processOutboxEvents() {
        Timer.Sample sample = Timer.start();
        
        try {
            log.debug("Iniciando procesamiento de eventos Outbox");
            
            List<OutboxEntity> unprocessedEvents = outboxService.getUnprocessedEvents(BATCH_SIZE);
            
            if (unprocessedEvents.isEmpty()) {
                log.debug("No hay eventos pendientes en el outbox");
                return;
            }
            
            log.info("Procesando {} eventos del outbox", unprocessedEvents.size());
            
            List<UUID> successfulEventIds = new ArrayList<>();
            int successCount = 0;
            int failureCount = 0;
            
            for (OutboxEntity event : unprocessedEvents) {
                try {
                    boolean success = publishEvent(event);
                    if (success) {
                        successfulEventIds.add(event.getId());
                        successCount++;
                        publishedEventsCounter.increment();
                        log.debug("Evento {} publicado exitosamente", event.getId());
                    } else {
                        failureCount++;
                        failedEventsCounter.increment();
                        log.warn("Falló la publicación del evento: {}", event.getId());
                    }
                } catch (Exception e) {
                    failureCount++;
                    failedEventsCounter.increment();
                    log.error("Error procesando evento {}: {}", event.getId(), e.getMessage(), e);
                }
            }
            
            // Marcar eventos exitosos como procesados
            if (!successfulEventIds.isEmpty()) {
                outboxService.markEventsAsProcessed(successfulEventIds);
            }
            
            log.info("Procesamiento completado - Exitosos: {}, Fallidos: {}", 
                    successCount, failureCount);
            
        } catch (Exception e) {
            log.error("Error en el procesamiento batch del outbox", e);
        } finally {
            sample.stop(publishingTimer);
        }
    }

    /**
     * Publica un evento individual a RabbitMQ
     */
    private boolean publishEvent(OutboxEntity event) {
        try {
            String routingKey = determineRoutingKey(event);
            Message message = createRabbitMessage(event);
            CorrelationData correlationData = new CorrelationData(event.getId().toString());
            
            log.debug("Enviando evento {} a RabbitMQ con routing key: {}", 
                    event.getId(), routingKey);
            
            rabbitTemplate.send(NOTIFICATIONS_EXCHANGE, routingKey, message, correlationData);
            
            log.debug("Evento {} enviado exitosamente a RabbitMQ", event.getId());
            return true;
            
        } catch (Exception e) {
            log.error("Error enviando evento {} a RabbitMQ: {}", event.getId(), e.getMessage(), e);
            return false;
        }
    }

    /**
     * Determina la routing key basada en el tipo de evento
     */
    private String determineRoutingKey(OutboxEntity event) {
        return switch (event.getType()) {
            case "EmailRequested.v1" -> "email.requested";
            case "SmsRequested.v1" -> "sms.requested";
            default -> {
                log.warn("Tipo de evento desconocido: {}", event.getType());
                yield "unknown.event";
            }
        };
    }

    /**
     * Crea un mensaje de RabbitMQ a partir de un evento del outbox
     */
    private Message createRabbitMessage(OutboxEntity event) throws Exception {
        String messageBody = objectMapper.writeValueAsString(event.getPayload());
        
        MessageProperties properties = new MessageProperties();
        properties.setContentType(MessageProperties.CONTENT_TYPE_JSON);
        properties.setDeliveryMode(MessageProperties.DEFAULT_DELIVERY_MODE);
        properties.setTimestamp(java.util.Date.from(event.getCreatedAt()));
        
        // Headers para trazabilidad
        properties.getHeaders().put("eventId", event.getId().toString());
        properties.getHeaders().put("eventType", event.getType());
        properties.getHeaders().put("aggregateType", event.getAggregateType());
        properties.getHeaders().put("aggregateId", event.getAggregateId());
        properties.getHeaders().put("source", "monolith");
        
        if (event.getIdempotencyKey() != null) {
            properties.getHeaders().put("idempotencyKey", event.getIdempotencyKey());
        }
        
        // Correlation ID si está disponible en el payload
        try {
            Object correlationId = event.getPayload().get("correlation_id");
            if (correlationId != null) {
                properties.setCorrelationId(correlationId.toString());
                properties.getHeaders().put("correlationId", correlationId.toString());
            }
        } catch (Exception e) {
            log.debug("No se pudo extraer correlation_id del payload: {}", e.getMessage());
        }
        
        return MessageBuilder
                .withBody(messageBody.getBytes())
                .andProperties(properties)
                .build();
    }

    /**
     * Limpia eventos procesados antiguos - ejecuta diariamente a las 2:30 AM
     */
    @Scheduled(cron = "${notifications.outbox.cleanup-cron:0 30 2 * * ?}")
    @Transactional
    public void cleanupOldProcessedEvents() {
        log.info("Iniciando limpieza de eventos procesados antiguos");
        
        try {
            int deletedCount = outboxService.cleanupOldProcessedEvents();
            log.info("Limpieza completada - {} eventos eliminados", deletedCount);
            
        } catch (Exception e) {
            log.error("Error durante la limpieza de eventos antiguos", e);
        }
    }

    /**
     * Obtiene estadísticas del dispatcher
     */
    public DispatcherStatistics getStatistics() {
        OutboxService.OutboxStatistics outboxStats = outboxService.getStatistics();
        
        return DispatcherStatistics.builder()
                .unprocessedEvents(outboxStats.unprocessedEvents)
                .processedLastHour(outboxStats.processedLastHour)
                .totalPublished(publishedEventsCounter.count())
                .totalFailed(failedEventsCounter.count())
                .averageProcessingTimeSeconds(outboxStats.averageProcessingTimeSeconds)
                .build();
    }

    /**
     * Estadísticas del dispatcher
     */
    public static class DispatcherStatistics {
        public final long unprocessedEvents;
        public final long processedLastHour;
        public final double totalPublished;
        public final double totalFailed;
        public final double averageProcessingTimeSeconds;
        
        private DispatcherStatistics(DispatcherStatisticsBuilder builder) {
            this.unprocessedEvents = builder.unprocessedEvents;
            this.processedLastHour = builder.processedLastHour;
            this.totalPublished = builder.totalPublished;
            this.totalFailed = builder.totalFailed;
            this.averageProcessingTimeSeconds = builder.averageProcessingTimeSeconds;
        }
        
        public static DispatcherStatisticsBuilder builder() {
            return new DispatcherStatisticsBuilder();
        }
        
        public static class DispatcherStatisticsBuilder {
            private long unprocessedEvents;
            private long processedLastHour;
            private double totalPublished;
            private double totalFailed;
            private double averageProcessingTimeSeconds;
            
            public DispatcherStatisticsBuilder unprocessedEvents(long unprocessedEvents) {
                this.unprocessedEvents = unprocessedEvents;
                return this;
            }
            
            public DispatcherStatisticsBuilder processedLastHour(long processedLastHour) {
                this.processedLastHour = processedLastHour;
                return this;
            }
            
            public DispatcherStatisticsBuilder totalPublished(double totalPublished) {
                this.totalPublished = totalPublished;
                return this;
            }
            
            public DispatcherStatisticsBuilder totalFailed(double totalFailed) {
                this.totalFailed = totalFailed;
                return this;
            }
            
            public DispatcherStatisticsBuilder averageProcessingTimeSeconds(double averageProcessingTimeSeconds) {
                this.averageProcessingTimeSeconds = averageProcessingTimeSeconds;
                return this;
            }
            
            public DispatcherStatistics build() {
                return new DispatcherStatistics(this);
            }
        }
    }
}