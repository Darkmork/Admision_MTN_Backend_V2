package com.desafios.admision_mtn.filter;

import com.desafios.admision_mtn.util.TraceCorrelationUtil;
import io.micrometer.tracing.Span;
import io.micrometer.tracing.Tracer;
import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.UUID;

/**
 * HTTP Filter for trace correlation and context propagation
 * 
 * Responsibilities:
 * - Extract/generate correlation IDs from HTTP headers
 * - Propagate trace context across request boundaries  
 * - Set up SLF4J MDC for structured logging
 * - Add business context to spans
 * - Handle Chilean privacy requirements
 */
@Component
@Order(1)
public class TraceCorrelationFilter implements Filter {
    
    private static final Logger logger = LoggerFactory.getLogger(TraceCorrelationFilter.class);
    
    // Header names for correlation
    public static final String CORRELATION_ID_HEADER = "X-Correlation-ID";
    public static final String TRACE_ID_HEADER = "X-Trace-ID";
    public static final String SPAN_ID_HEADER = "X-Span-ID";
    
    private final TraceCorrelationUtil traceUtil;
    private final Tracer tracer;
    
    @Autowired
    public TraceCorrelationFilter(TraceCorrelationUtil traceUtil, Tracer tracer) {
        this.traceUtil = traceUtil;
        this.tracer = tracer;
    }
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // Extract or generate correlation ID
        String correlationId = extractOrGenerateCorrelationId(httpRequest);
        traceUtil.setCorrelationId(correlationId);
        
        // Get current span and update MDC
        Span currentSpan = tracer.currentSpan();
        if (currentSpan != null) {
            traceUtil.updateMdcFromTraceContext();
            addHttpContextToSpan(currentSpan, httpRequest);
        }
        
        // Add correlation headers to response
        httpResponse.setHeader(CORRELATION_ID_HEADER, correlationId);
        if (currentSpan != null) {
            httpResponse.setHeader(TRACE_ID_HEADER, currentSpan.context().traceId());
            httpResponse.setHeader(SPAN_ID_HEADER, currentSpan.context().spanId());
        }
        
        // Log request start
        logRequestStart(httpRequest, correlationId);
        
        try {
            // Continue filter chain
            chain.doFilter(request, response);
            
            // Log successful completion
            if (currentSpan != null) {
                currentSpan.tag("http.status_code", String.valueOf(httpResponse.getStatus()));
                currentSpan.tag("http.response.success", String.valueOf(httpResponse.getStatus() < 400));
            }
            
            logger.info("Request completed successfully - Status: {} Path: {}", 
                httpResponse.getStatus(), httpRequest.getRequestURI());
            
        } catch (Exception e) {
            // Log error and add to span
            if (currentSpan != null) {
                currentSpan.tag("error", "true");
                currentSpan.tag("error.type", e.getClass().getSimpleName());
                currentSpan.tag("error.message", e.getMessage() != null ? e.getMessage() : "Unknown error");
            }
            
            logger.error("Request failed - Path: {} Error: {}", httpRequest.getRequestURI(), e.getMessage(), e);
            throw e;
            
        } finally {
            // Clean up MDC
            traceUtil.clearContext();
        }
    }
    
    /**
     * Extract correlation ID from headers or generate new one
     */
    private String extractOrGenerateCorrelationId(HttpServletRequest request) {
        String correlationId = request.getHeader(CORRELATION_ID_HEADER);
        
        if (correlationId == null || correlationId.trim().isEmpty()) {
            correlationId = "mtn-" + UUID.randomUUID().toString().substring(0, 12);
        }
        
        return correlationId;
    }
    
    /**
     * Add HTTP-specific context to span
     */
    private void addHttpContextToSpan(Span span, HttpServletRequest request) {
        // HTTP method and path
        span.tag("http.method", request.getMethod());
        span.tag("http.url.path", request.getRequestURI());
        
        // Query parameters (PII-safe)
        String queryString = request.getQueryString();
        if (queryString != null && !queryString.isEmpty()) {
            // Don't log sensitive parameters
            if (!containsSensitiveParams(queryString)) {
                span.tag("http.url.query", queryString);
            } else {
                span.tag("http.url.query", "[FILTERED]");
            }
        }
        
        // User agent (first part only for privacy)
        String userAgent = request.getHeader("User-Agent");
        if (userAgent != null && userAgent.length() > 20) {
            span.tag("http.user_agent.short", userAgent.substring(0, 20) + "...");
        }
        
        // Remote IP (mask last octet for privacy)
        String remoteAddr = request.getRemoteAddr();
        if (remoteAddr != null && remoteAddr.contains(".")) {
            String maskedIp = maskIpAddress(remoteAddr);
            span.tag("http.client_ip", maskedIp);
        }
        
        // Content type
        String contentType = request.getContentType();
        if (contentType != null) {
            span.tag("http.content_type", contentType);
        }
        
        // Request size
        long contentLength = request.getContentLengthLong();
        if (contentLength > 0) {
            span.tag("http.request.size", String.valueOf(contentLength));
        }
        
        // Business context from URL patterns
        addBusinessContextFromUrl(span, request.getRequestURI());
    }
    
    /**
     * Add business context based on URL patterns
     */
    private void addBusinessContextFromUrl(Span span, String uri) {
        if (uri == null) return;
        
        // Application-related endpoints
        if (uri.contains("/applications")) {
            span.tag("mtn.domain", "applications");
            if (uri.contains("/submit")) {
                span.tag("mtn.operation", "submit_application");
            } else if (uri.contains("/status")) {
                span.tag("mtn.operation", "check_status");
            }
        }
        
        // Evaluation endpoints
        if (uri.contains("/evaluations")) {
            span.tag("mtn.domain", "evaluations");
            if (uri.contains("/create")) {
                span.tag("mtn.operation", "create_evaluation");
            } else if (uri.contains("/submit")) {
                span.tag("mtn.operation", "submit_evaluation");
            }
        }
        
        // User management
        if (uri.contains("/users")) {
            span.tag("mtn.domain", "users");
        }
        
        // Authentication
        if (uri.contains("/auth")) {
            span.tag("mtn.domain", "authentication");
            if (uri.contains("/login")) {
                span.tag("mtn.operation", "login");
            } else if (uri.contains("/register")) {
                span.tag("mtn.operation", "register");
            }
        }
    }
    
    /**
     * Check if query string contains sensitive parameters
     */
    private boolean containsSensitiveParams(String queryString) {
        String lowerQuery = queryString.toLowerCase();
        return lowerQuery.contains("password") || 
               lowerQuery.contains("token") || 
               lowerQuery.contains("secret") ||
               lowerQuery.contains("rut") ||
               lowerQuery.contains("email");
    }
    
    /**
     * Mask IP address for privacy (keep first 3 octets)
     */
    private String maskIpAddress(String ip) {
        if (ip == null || !ip.matches("\\d+\\.\\d+\\.\\d+\\.\\d+")) {
            return ip;
        }
        
        String[] parts = ip.split("\\.");
        if (parts.length == 4) {
            return parts[0] + "." + parts[1] + "." + parts[2] + ".***";
        }
        
        return ip;
    }
    
    /**
     * Log request start with PII-safe information
     */
    private void logRequestStart(HttpServletRequest request, String correlationId) {
        logger.info("Request started - Method: {} Path: {} CorrelationID: {} UserAgent: {}", 
            request.getMethod(),
            request.getRequestURI(),
            correlationId,
            request.getHeader("User-Agent") != null 
                ? request.getHeader("User-Agent").substring(0, Math.min(20, request.getHeader("User-Agent").length())) + "..."
                : "Unknown");
    }
}